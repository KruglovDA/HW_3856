# GIT список команд
![Здесь находится мем1](image1.jpg)

* сделать текущую папку репозиторием: *git init*
* далее **надо представиться гиту** (вроде как один раз): *git config --global user.name* "Имя пользователя" и  *git config --global user.email* почта
* начать отслеживать конкретный файл: *git add имяфайла.расширение*. **Файлы называть без пробелов!**

потом можно печатать что нужно в файле

***Как сохранить версию файла:***
* **первым делом сохранить его**, обычным сохранением, через меню программы или Ctrl+S
* команда *git add имяфайла.расширение* снова

можно для собственного спокойствия вызвать *git status* и убедиться, что он пишет о наличии неоткоммиченных изменений в файле (**внимание, если какой-то из предыдущих шагов забыт**, статус выдаст, что никаких изменений в файле не было, даже когда они, очевидно, были - это сигнал проверить, что пропущено) 
* и сделать коммит с комментарием о внесенных изменениях: *git commit -a -m* "комментарий"

**Эти шаги повторяются в этом порядке всякий раз при сохранении изменений.**

Посмотреть, какие коммиты и сколько их было сделано, можно ваызовом журнала изменений *git log*. **Внимание, чтобы выйти из режима журнала в обычный режим, надо нажать на клавишу q** (обнаружено, что ею же выходить надо из спецрежима команды *git diff*)

![Здесь находится мем2](image2.jpg)
## Коммиты и ветки, или как переключаться между версиями файла.
**Коммиты** = собственно версии файла, а точнее, наборы различий между двумя соседними по времени сохранения версиями файла. Они по порядку их создания группируются гитом в **ветви** - последовательности коммитов. Переключаться можно как между отдельными коммитами, так и между ветвями. Команда на переключение: *git checkout номеркоммита* (длинная последовательность символов в абзаце желаемого коммита в журнале изменений) или *git checkout имя_желаемой_ветви*.

Внимание! Если переключиться **между отдельными коммитами**, возникнет состояние ***DETACHED HEAD***, о котором гит вдобавок выдаст оповещение в терминале. Что это такое: отныне все текущие изменения файла с точки зрения гита "подвешены в пустоте" - они не входят ни в тот коммит, на который мы переключились, ни в одну из имеющихся ветвей. В этом состоянии **файл можно менять, но вот сделать новый коммит гит не может** - и статус будет выдавать все время, что никаких изменений для сохранения не имеется. Исправляется это через создание дополнительной ветки для этих изменений. *с подробностями разберусь и добавлю позже, если возникнет такая необходимость - после неуютного самостоятельного знакомства с этой особенностью во время повторения за Ильнаром на лекции 1 вызывать ее намеренно не хочу*

**Ветки** - параллельные друг другу последовательности коммитов, обозначаются именами, заданными пользователем при их создании. Ветвление можно сделать в любой момент от любой ветки; при начале отслеживания файла гит создает единственную, по умолчанию, ветку master (название по умолчанию можно поменять в настройках - например, на гитхабе (см.ниже) главную ветвку называют main): от нее и начинается ветвление. 

**Создание ветки**: *git branch имя_новой_ветки_желательно_отражающее_смысл_ее_содержимого*. Статус укажет, в какой ветке мы сейчас находимся.


Внимание! Теперь:
* Созданный коммит будет **записан только и именно в ту ветку, в который ты сейчас находишься**. При переключении на ветку будет видна версия файла, соответствующая последнему созданному в данной конкретной ветке коммиту. 
* Журнал изменений покажет в обратном порядке **коммиты текущей ветки и коммиты той ветки, от которой текущая ветка отходит**: и так далее, по дереву ветвей, к его началу, то есть вплоть до самого первого коммита.

Когда в данную ветку закончили вносить изменения, и все в ней ОК, ее можно **слить с другой веткой**: по логике вещей, чаще сливают ее с ее же материнской, хотя можно и с любой другой, если необходимо. 

Для слияния надо: 
1. **Переключиться на ту ветку, в которую мы хотим внести** коммиты из нашей законченной ветки;
2. *git merge имя_законченной_ветки*

Гит автоматически добавит коммиты ***из названной в команде ветки в ту ветку, на которой мы находились*** на момент подачи команды на слияние.

При слиянии может возникнуть ***конфликт***: если **в обеих сливаемых ветвях после последнего общего для них коммита были сделаны коммиты**, то у гита при слиянии в наличии **обнаруживаются две версии** последовательностей коммитов, которые нужно упихать теперь в одну. Самостоятельно гит этого не сделает, и спросит пользователя, какую из версий оставить, или же оставить их обе. **Выбрать**, что хочешь: это гит и сохранит в той ветке, где мы находимся. 

**Когда** над файлом **трудятся несколько** человек, **назначается один ответственный за слияние** ветвей: и только он слияние и делает, когда убедится в полной готовности ветвей.

![Здесь находится мем3](image3.png)

Еще команды, относящиеся к ветвям:
* **Вывести список всех** имеющихся ветвей: *git branch* Та ветка, на которой мы сейчас находимся, будет выделена зеленым цветом.
* **Удалить** ненужную ветку: *git branch -d имя_удаляемой_ветки*
* **Сравнить** два последних коммита: *git diff* (покажет разницу между коммитами текущей ветки) или *git diff ветка1 ветка2* (покажет разницу между последними коммитами двух указанных веток)

## Когда в репозитории лежит не один файл
В папке, ставшей по воле владельца гита репозиторием, может лежать несколько файлов. Каких - зависит от конкретного случая: несколько текстов, картинки для вставки в текст, etc. Гит видит все эти файлы: и если они в гит не добавлены (*git add имяфайла.расширение*), т.е. он их не отслеживает, всякий раз статус будет напоминать, что они есть и не отслеживаются (и буковку U рисовать напротив них в списке файлов).

Чтобы **избавиться от** настойчивых **напоминалок** гита **про неотслеживаемые файлы**, можно сделать специальное действие: создать в этой папке - через список файлов в левой менюшке - файл со специальным названием ***.gitignore***. В нем в строки, по одной на имя, написать имя одного из файлов, которые гиту надо игнорировать. После составления этого списка добавить этот файл в гит как отслеживаемый, и сделать коммит. И больше статус напоминать о перечисленных файлах не будет: гит перестанет обращать на них внимание (хотя будет видеть и отображать их присутствие в репозитории).

**Как добавить картинки** в создаваемый в Visual Studio Code файл:

1. Лучше создать для картинок отдельную ветку (и переключиться на нее не забыть)
2. На языке разметки Markdown (что использован в этом файле) команда на вставку картинки будет ***![Текст, который будет отображаться вместо картинки, если ее не удастся отобразить](адрес картинки или, если картинка лежит в том же репозитории, что и тот файл, в который мы ее вносим, просто имякартинки.расширение)***
3. Закоммитить изменения!

Картинки и пр. добавляемые файлы, особенно если они большие, добавлять в гит не принято, и они лежат в репозитории как неотслеживаемые. Можно их добавить в гитигнор.

## Работа с удаленным репозиторием GitHub
**Удаленные репозитории** - основное средство для работы над файлом нескольких человек. **На сайте GitHub** выкладывается в создаваемый на сайте репозиторий **начальная/текущая, она же общая для всех версия файла**. Гитхаб **присвоит этому репозиторию ссылку**, которую можно и нужно скопировать, рассылать кому хочешь и т.д. По этой ссылке репозиторий может скачать любой человек, даже не имеющий акаунта в данном сервисе удаленных репозиториев. 

Каждый член команды проекта: 
* **копирует общую версию себе** на комп: *git clone ссылканарепозиторийсгнерированнаягитхабом*
* **вносит** на своем компе в нее **изменения и коммитит их**
* **подгружает себе** коммиты с удаленного репозитория - как залитые туда другими членами команды, так и сделанные тобою же непосредственно на гитхабе: *git pull  ссылканарепозиторийсгнерированнаягитхабом*
* **подгружает сделанные им коммиты** (т.е. свою версию файла) (*git push ссылканарепозиторийсгнерированнаягитхабом*) в ту самую общую для всех версию файла в удаленном репозитории. Можно подгрузить конкретную ветку: *git push ссылканарепозиторийсгнерированнаягитхабом имя_конкретной_ветки*

ВНИМАНИЕ! 

*git clone* **набирается** в терминале **после открытия** в Visual Studio Code **той папки, в которую** планируешь **положить** скачиваемый проект. Гит **создаст папку** с нужным файлом **внутри этой папки**: надо будет перейти на ту папку и открыть в ней терминал.

*git pull* автоматически **подразумевает** *merge* между локальной и подгружаемой с гитхаба версиями файла: т.е. **когда/если возникнут конфликты** при слиянии, с ними надо будет разобраться (см.выше, как это делать)

Для *git push* **необходимо быть авторизованной на внешнем**, то есть удаленном, т.е. гитхабовском в данном случае, **репозитории**. Надо "подружить" свой гит с аккаунтом на гитхабе: и гит подскажет, как это сделать, если набрать *git push*, а связки еще не было, и гитхаб предложит скопировать с него набор команд на выбор, смотря что хочешь сделать.
Также эта команда **не позволит выполнить** подгрузку, **если в удаленном репозитории были изменения, конфликтующие** с теми, которые мы пытаемся туда подгрузить: делается это для того, чтобы не потерять журнал изменений удаленного репозитория. В таком случае сначала надо подгрузить эти изменения себе на комп, лучше отдельной веткой, слить их со своей версией и тогда уже подгрузить ее на удаленный репозиторий. Есть способ пересилить этот запрет: *git push ссылканарепозиторийсгнерированнаягитхабом --force* - но лучше так не делать! Возненавидят.

Хорошим тоном считается **создать** в репозитории с проектом **файл-описание**: он называется стандартно ***README.md***. ЕГо можно создать как вручную у себя, так и при создании удаленного репозитория - гитхаб предложит сразу его создать. Туда пишем, что это за проект вообще и пр.сведения о нем. Добавить его в гит и закоммитить внесенную туда инфу не забывать!

Еще такая ситуация возникает, когда много человек хотят внести изменения в проект: прямо вот всем 100500 желающим позволить вносить свои правки в проект нельзя, гиблое дело, но кто-то из них дело может предлагать. **Опция предложения изменений** для проекта ***pull request***:

1. На гитхабе **создать** в своем профиле **собственное ответвление** интересующего нас **проекта**. Для этого заходим **на страницу репозитория того самого проекта**, и справа вверху будет **кнопка** ***fork***.
2. **Подгрузить к себе** на комп (*git clone ссылканарепозиторийсгнерированнаягитхабом*) **СВОЮ копию** того репозитория
3. **В локальной версии** сделать **свою ветку и туда** вносить и коммитить свои изменения
4. **README.md создать** (если его еще не было) **или заполнить** инфой о том, что предлагаешь изменить в проекте, обязательно!
5. **Подгрузить** свою версию **в свою копию удаленного** репозитория того проекта (*git push ссылканарепозиторийсгнерированнаягитхабом*)
6. **На гитхабе** на странице удаленного репозитория **появится кнопка** ***Compare and pull request***. Она открывает окошко, где гит сам сравнит две версии проекта, покажет, можно их слить или какие-то проблемы могут возникнуть при слиянии, и предложит накидать послание владельцу исходной версии. Далее уже хозяин исходника будет запрос смотреть и решать, вливать ли это к себе.